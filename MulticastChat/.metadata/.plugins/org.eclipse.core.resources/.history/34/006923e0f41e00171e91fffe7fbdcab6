package MulticastSocket;

import java.net.UnknownHostException;
import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.net.MulticastSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.io.IOException;
import java.util.ArrayList;

public class Main {
	
	protected static ArrayList <String> aList;
	private static MulticastSocket s;
	public static InetAddress group;
	public static int ports, portc;
	public static String address;
	public static String smile;
	public static String tongue;
	
	public Main ( ) {
		
		smile = "<img src=https://lh3.googleusercontent.com/5dPwO_QMb2P8gOJ1tfQ0_uOw8qqv2Vmpzhnb800Q-c30xQJ7jDOqIiEYGUBX-t6hDhrSb06UD_HUxDHupqTue48nrM8qjnEUxf6Fc4OIYmPhZTLkdokkU_cTxWnFHIeOU5F1gA=s28-no>";		
		tongue = "<img src =https://lh3.googleusercontent.com/uT4oZVyvDKfu4QY4XFQKqRkrM5AHDcwdgEBBxV5I0uIKeAoOtA46kucBKfavdximsC28OuExPn2RQUinUvMqFscjHhtFxg52iQke8bwUwDkIK1pFqK8r9h24BWA01Bp9zXfKd28V_vBOr0MYwNMRMAVN_4G4DYhzlj_fMC3jii4B64wHgygMS5WcnLG8QOiE1VX7J2-D779r5sjB86I1xvoGeBH8RK0yh2mPx25FdQ8rsqfxe_eOJyX0WXNuDw8m-OdthXfh9Bp6-f3MaUdv4kZvK8zun3-wpSSNaYFZ8RrWX8Jgdm2_WU4jxmluX4cSYCYhC-mSEVrePa0Kn1lT__QOL8A7SbvuA4hxzecf4qCet5VrJ-ZtLrl2xzjXsPXkEGxRfZQALwHSxJdcNHW2njsBbWkt3GlYYOITH32zeCmNNK0JYHM_x9Sp02LkkAwDP-xlhxpoefWhdEs9PisJa1CJfkijqXbhAmf3sdaeZFGfg4m57oEMs2vh6HyXKFV3_cq6f9iYpTe7VF95RY3K-Im7K_eDieLMBPn_cHjoWUbMDOmBOtseWoS7QW_QMfK3BI-RwCAvHq9uyE6h8QFUt7WKHKk-OP-Pq59uuYAgs99xMiho=w22-h21-no>";
	} // End constructor.

	public static void main ( String [ ] args ) {
		
		try {
			aList = new ArrayList <String> ( );
			System.setProperty ( "java.net.preferIPv4Stack", "true" );
			ports = 9000;
			portc = 9001;
			address = "230.1.1.1";
			s = new MulticastSocket ( ports );
			System.out.println ( "\n\tMulticast service initialized..." );
			group = null;
			try {
				group = InetAddress.getByName ( address );
			} catch ( UnknownHostException e ) {
				System.err.println ( "\n\tInvalid address." );
				System.exit ( 0 );
			} // End try - catch.
			s.joinGroup ( group );
			s.setTimeToLive ( 200 );
			for ( ; ; ) {
				DatagramPacket p = new DatagramPacket ( new byte [ 1500 ], 1500 );
				s.receive ( p );
				String msg = new String ( p.getData ( ), 0, p.getLength ( ) );
				System.out.println ( "\n\tMessage received from: " + p.getAddress ( ) + " : " + p.getPort ( ) + "\n\tMessage: " + msg );
				Type ( msg );
				try {
					Thread.sleep ( 5000 );
				} catch ( InterruptedException ie ) { } // End try - catch.
			} // End for.
		} catch ( Exception e ) {
			e.printStackTrace ( );
		} // End try - catch.	
		
	} // End main.
	
	/* The type of the message received from the client
	 * can be <msg>, <init> or <private>. If it's <msg>, the
	 * server will send the message to the common chat window, 
	 * <init> if a new user wants to join to the conversation,
	 * and <private> to open a personal chat with another user.
	 */
	
	public static void Type ( String msg ) throws IOException {
		
		String [ ] sp = msg.split ( " " );
		msg = "";
		
		if ( sp [ 0 ].equalsIgnoreCase ( "<init>" ) ) {
			String type = "<init>";
			String userName = "";
			byte [ ] b = type.getBytes ( );
			byte [ ] b1;
			String user;
			DatagramPacket p = new DatagramPacket ( b, b.length, group, portc );
			s.send ( p );
			for ( int i = 1 ; i < sp.length ; i++ ) {
				userName = userName + sp [ i ] + " ";  
			} // End for.
			aList.add ( userName );
			OnlineUsers ( );
			for ( int i = 0 ; i < aList.size ( ) ; i++ ) {
				user = aList.get ( i );
				b1 = user.getBytes ( );
				DatagramPacket p1 = new DatagramPacket ( b1, b1.length, group, portc );
				s.send ( p1 );
			} // End for.
		} // End if.
		
		if ( sp [ 0 ].equalsIgnoreCase ( "<msg>" ) ) {
			String type = "<msg>";
			String aux = "";
			byte [ ] b1 = type.getBytes ( );
			DatagramPacket p1 = new DatagramPacket ( b1, b1.length, group, portc );
			s.send ( p1 );
			for ( int i = 1 ; i < sp.length ; i++ ) {
				msg = msg + sp [ i ] + " ";  
			} // End for.
			aux = Emoticon ( msg );
			msg = aux;
			System.out.println(aux);
			byte [ ] b = msg.getBytes ( );
			DatagramPacket p = new DatagramPacket ( b, b.length, group, portc );
			s.send ( p );
		} // End if.
		
		if ( sp [ 0 ].equalsIgnoreCase ( "<private>" ) ) {
			String msgFrom = sp [ sp.length - 1 ];
			String msgFor = "";
			for ( int i = 1 ; i < sp.length - 2 ; i++ ) {
				msgFor = msgFor + sp [ i ];  
			} // End for.
			System.out.println( "\n\tPrivate Message for: " + msgFor + ". From: " + msgFrom + "." );
			String type = "<private>";
			byte [ ] b = type.getBytes ( );
			DatagramPacket p = new DatagramPacket ( b, b.length, group, portc );
			s.send ( p );
			b = msgFrom.getBytes ( );
			DatagramPacket p1 = new DatagramPacket ( b, b.length, group, portc );
			s.send ( p1 );
			b = msgFor.getBytes ( );
			DatagramPacket p2 = new DatagramPacket ( b, b.length, group, portc );
			s.send ( p2 );
		} // End if.
		
	} // End Type.
	
	/* The client needs to know how man users are online, the method OnlineUsers
	 * gets the size of the arraylist, convert the integer into a byte array,
	 * and the server send the information as a datagram packet.
	 */
	
	public static void OnlineUsers ( ) throws IOException {
		
		int size = aList.size ( );
		ByteArrayOutputStream baos = new ByteArrayOutputStream ( );
		DataOutputStream dos = new DataOutputStream ( baos );
		dos.writeInt ( size );
		dos.flush ( );
		byte [ ] b = baos.toByteArray ( );
		DatagramPacket p = new DatagramPacket ( b, b.length, group, portc );
		s.send ( p );
		baos.close ( );
		dos.close ( );
		
	} // End OnlineUsers.
	
	public static String Emoticon ( String msg ) {
		
		String aux = "";
		for ( int i = 0 ; i < msg.length ( ) ; i++ ) {
			if ( msg.charAt ( i ) == ':' ) {
				System.out.println(msg.charAt(i));
				if ( msg.charAt ( i + 1 ) == 'D' ) {
					System.out.println(msg.charAt(i+1));
					aux = aux + smile;
					i += 2;
				} else if ( msg.charAt ( i + 1 ) == 'P' ) {
					System.out.println(msg.charAt(i+1));
					aux = aux + tongue;
					i += 2;
				} else {
					aux = aux + msg.charAt ( i );
				} 
			} else {
				aux = aux + msg.charAt ( i );
			}
		} // End for.
		
		return aux;
		
	} // End emoticon.

} // End class.
